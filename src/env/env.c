/*
 * header
 * MIT license
 * wut
 * Tue Nov 20 18:58:45 EST 2012
 */

#include "../shared.h"
#include "unistd.h"

/*
 * The following are generated by Makefile
 * and are passed directly to GCC/clang
 * with -D switches
 */

#ifndef VERSION
    #define VERSION      "unknown"
#endif

#ifndef COMPILE_DATE
    #define COMPILE_DATE "unknown"
#endif

#define LICENSE      "MIT"

/*refers to envp*/
extern char **environ;

/*when given -0, --null, replace new-lines with '0'*/
char  g_paramNull = 0;

/*set and unset the general params*/
void param_null(char const * const *str, int argn) {
    g_paramNull = 1;
}
void ignore_env(char const * const *str, int argn) {
    clearenv();
}

/*Print the environment to stdout, take of g_paramNull for formatting*/
void print_env(void)
{
    char **envp = environ;
    while (envp && *envp) {
        printf("%s%c", *envp, (g_paramNull ? '0' : '\n'));
        envp++;
    }
}

void unset_env(char const * const *str, int argn)
{
    char const *temp = str[argn];
    while (*temp && *(++temp)!='=');

    if (*temp == '=') {
        unsetenv(++temp);
    }

    else {
        fprintf(stderr, "Missing '=' operator\n");
    }
}

void print_usage(char const * const *str, int argn)
{
    printf("Usage: %s [OPTION]... [-] [NAME=VALUE]... [COMMAND [ARG]...]\n", str[0]);
    printf("Set each NAME to VALUE in the environment and run COMMAND.\n");
    printf("  -i, --ignore-environment  start with an empty environment\n");
    printf("  -0, --null           end each output line with 0 byte rather than newline\n");
    printf("  -u, --unset=NAME     remove variable from the environment\n");
    printf("      --help     display this help and exit\n");
    printf("      --version  output version information and exit\n\n");
    printf("A mere - implies -i.  If no COMMAND, print the resulting environment.\n");
    exit(0);
}

void print_version(char const * const *str, int argn)
{
    printf("env version: "VERSION" (gentils git)\n");
    printf("Build date: "COMPILE_TIME"\n");
    printf("License "LICENSE"\n");
    exit(0);
}

/* 
 * The following struct is responsible
 * for handling command line arguments
 * in a simple way (linear search)
 */

typedef struct {
    char const *name;
    void (*function)(char const * const * str, int argn);
} ArgList;

ArgList ArgInfo[]= {
        { .name="--version", .function=&print_version },
        { .name="--help",    .function=&print_usage   },

        { .name="-",                    .function=&ignore_env  },
        { .name="-i",                   .function=&ignore_env  },
        { .name="--ignore-environment", .function=&ignore_env  },

        { .name="-u",        .function=&unset_env     },
        { .name="--unset",   .function=&unset_env     },
        { .name="-0",        .function=&param_null  },
        { .name="--null",    .function=&param_null  },

        { .name=NULL,        .function=0               }
};

void handle_arguments(char const * const *argv)
{
    char const * const *arg = argv;
    int argn = 0, i, found = 0;
    while (*(++arg))
    {
        ++argn;

        /* check for parameters */
        for (i = 0; ArgInfo[i].function; ++i)
        {
            char const * const name = ArgInfo[i].name;

            if (!strncmp(*arg, name, strlen(name)))
            {
                /* call the function with all agruments
                 * and integer denoting the current argument*/
                ArgInfo[i].function(argv, argn);
                found = 1;
                break;
            }
        }

        if (found) { found = 0; continue; }

        /* Check if argument sets a variable */
        char const *temp = *arg;
        int var_len = 0;

        /* record length of var, rewind to the '=' */
        while (*temp && *(temp++)!='=') { var_len++; };
        --temp;

        if (*temp == '=' && var_len > 0)
        {
            /* create string containing the variable name */
            char *var_name = (char*)malloc(var_len+1);
            memcpy(var_name, *arg, var_len);
            var_name[var_len] = 0;

            /* assign value to variable, free variable name */
            setenv(var_name, ++temp, 1);
            free(var_name);
            continue;
        }

        /* check for program to execute in new environment */
        if (!*(arg+1)) {
            /*This is the last argument*/
            char * const argv[2]={*arg, NULL};
            execvp(argv[0], argv);
        }

        printf("%s: extra operand `%sâ€™\n", argv[0], *arg);
        print_usage(argv, 0);
    }
}

int main(int argc, char const * const *argv)
{
    if (argc > 1)
        handle_arguments(argv);
    
    print_env();
    return 0;
}
